# -*- coding: utf-8 -*-
"""Documentation Intelligence

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yg30oWs3i47jZMw8abDWINjIKyXnd10a

# **Text Extraction in Engineering+Working+Drawing+Basics**
"""

!pip install pdfplumber pandas
from google.colab import files
import pdfplumber
import pandas as pd
import time

class PDFExtractor:
    """
    This class is used to extract text from PDF files and search for specific keywords,
    and save the extracted data to an Excel file.
    Attributes:
        pdf_path(str): The path to the PDF file.
        keywords(list of str): A list of keywords to search for.
        output_excel(str): The path where the Excel file will be saved.
        book_name(str): The name of the book will be seen in the Excel File.
    """
    def __init__(self, pdf_path, keywords, output_excel):
        """
        Initializes the PDFExtractor with the necessary parameters.
        Args:
            pdf_path (str): The path to the PDF file.
            keywords (list of str): A list of keywords to search for in the PDF text.
            output_excel (str): The path where the output Excel file will be saved.
        """
        self.pdf_path = pdf_path
        self.keywords = keywords
        self.output_excel = output_excel
        self.book_name = pdf_path.split("/")[-1]

    def extract_text_from_pdf(self):
        """
        Extracts text from the PDF file.
        """
        text_data = []
        with pdfplumber.open(self.pdf_path) as pdf:
            for page in pdf.pages:
                text_data.append(page.extract_text())
        return "\n".join(text_data) if text_data else "No text extracted"

    def search_keywords(self, text):
        """
        Searches for specific keywords in the extracted text and returns surrounding content.
        Args:
            text (str): The text extracted from the PDF.
        Returns:
            list of dict: A list of dictionaries containing the keyword and surrounding content.
        """
        results = []
        lines = text.split("\n")
        seen_snippets = set()
        for keyword in self.keywords:
            for i, line in enumerate(lines):
                if keyword.lower() in line.lower():
                    content_snippet = "\n".join(lines[max(0, i-2): min(len(lines), i+3)])
                    if content_snippet not in seen_snippets:
                        results.append({"Keyword": keyword, "Extracted Content": content_snippet})
                        seen_snippets.add(content_snippet)
        return results

    def save_excel(self, data):
        """
        Saves the extracted data to Excel file.
        Args:
            data (list of dict): The extracted data to be saved.
        """
        df = pd.DataFrame(data)
        df['Source Book'] = self.book_name
        df.to_excel(self.output_excel, index=False)
        print(f"Data saved to {self.output_excel}")

    def process_pdf(self):
        """
        Processes the PDF file by extracting text searching for keywords and saving them to Excel.
        If matches are found, the data is saved to Excel file and made available for download.
        """
        extracted_text = self.extract_text_from_pdf()
        extracted_data = self.search_keywords(extracted_text)

        if extracted_data:
            self.save_excel(extracted_data)
            time.sleep(2)
            files.download(self.output_excel)
        else:
            print("No matches found for the given keywords!")

uploaded = files.upload()

for file_name in uploaded.keys():
    if file_name.lower().endswith('.pdf'):
        keywords = ["Codes and Standards", "Material or Parts List"]
        output_excel = "/content/extracted_text.xlsx"
        pdf_extractor = PDFExtractor(file_name, keywords, output_excel)
        pdf_extractor.process_pdf()

"""# **Text Extraction in Table Format Autodesk Inventor Practice Part Drawings**

"""

!pip install PyPDF2 pandas

import re
from PyPDF2 import PdfReader
import pandas as pd
from google.colab import files

class PDFTextExtractor:
    """
    This class is used to extract specific content from a PDF file and save it to Excel file.

    Attributes:
        pdf_path (str): The path to the PDF file.
        output_excel (str): The path where the Excel file will be saved.
        book_name (str): The name of the book will be seen in the Excel File.
        pages_to_extract (list): The list of pages to extract the text.
    """
    def __init__(self, pdf_path, output_excel, pages_to_extract=None):
        """
        Initializes the PDFTextExtractor with the necessary parameters.

        Args:
            pdf_path (str): The path to the PDF file.
            output_excel (str): The path where the output Excel file will be saved.
            pages_to_extract (list): The list of pages to extract text from (default is all pages).
        """
        self.pdf_path = pdf_path
        self.output_excel = output_excel
        self.pages_to_extract = pages_to_extract
        self.book_name = pdf_path.split("/")[-1]

    def extract_text_from_pdf(self):
        """
        Extracts text from the specified pages of the PDF file using PyPDF2.

        Returns:
            str: The extracted text from the specified pages of the PDF.
        """
        reader = PdfReader(self.pdf_path)
        text = ""

        if not self.pages_to_extract:
            self.pages_to_extract = range(1, len(reader.pages) + 1)

        for page_num in self.pages_to_extract:
            page = reader.pages[page_num - 1]
            text += page.extract_text()

        return text

    def extract_file_name_description(self, text):
        """
        Extracts 'FILE NAME' and 'DESCRIPTION' from the extracted text using regex patterns.

        Args:
            text (str): The text extracted from the PDF.

        Returns:
            list of dict: A list of dictionaries containing 'FILE NAME' and 'DESCRIPTION' pairs.
        """
        pattern = re.compile(r"([A-Za-z0-9\s,-]+\.ipt)\s*(.*?)(?=(?:[A-Za-z0-9\s,-]+\.ipt|$))", re.DOTALL)
        matches = pattern.findall(text)
        extracted_data = [{"File Name": match[0].strip(), "Description": match[1].strip()} for match in matches]
        return extracted_data

    def save_to_excel(self, data):
        """
        Saves the extracted data to an Excel file.

        Args:
            data (list of dict): The extracted data is saved to the Excel file.
        """
        df = pd.DataFrame(data)
        df['Source Book'] = self.book_name
        df.to_excel(self.output_excel, index=False)
        print(f"Data saved to {self.output_excel}")

    def process_pdf(self):
        """
        Processes the PDF file by extracting text from the specified pages and searching for 'FILE NAME'
        and 'DESCRIPTION' patterns and saves the results to an Excel file.
        If matches are found the data is saved to an Excel file and made available for download.
        """
        text = self.extract_text_from_pdf()
        extracted_data = self.extract_file_name_description(text)

        if extracted_data:
            self.save_to_excel(extracted_data)
            files.download(self.output_excel)
        else:
            print("No 'FILE NAME' and 'DESCRIPTION' matches found!")

uploaded = files.upload()
for file_name in uploaded.keys():
    if file_name.lower().endswith('.pdf'):
        output_excel = "/content/extracted_data.xlsx"
        pdf_extractor = PDFTextExtractor(file_name, output_excel)
        pdf_extractor.process_pdf()

"""# **Extracting Widths from Autodesk Inventor Practice Part Drawings form specific page number in PDF**"""

!pip install PyMuPDF
import fitz
import pandas as pd
from google.colab import files

class PDFWidthExtractor:
    """
    A class to extract width values from a specific page of a PDF and save it to an Excel file.

    Attributes:
        pdf_path (str): The path to the PDF file to process.
        output_excel (str): The path to the output Excel file.
        page_number (int): The page number from which to extract the width.
    """

    def __init__(self, pdf_path, output_excel, page_number):
        """
        Initializes the PDFWidthExtractor with the specified PDF path, output Excel path, and page number.

        Args:
            pdf_path (str): Path to the PDF file.
            output_excel (str): Path to the output Excel file.
            page_number (int): The specific page number to process (1-based index).
        """
        self.pdf_path = pdf_path
        self.output_excel = output_excel
        self.page_number = page_number

    def extract_width_with_context(self, page):
        """
        Extracts width values from a single PDF page by searching for occurrences of the word "width".

        Args:
            page: A page object from the PDF.

        Returns:
            float: The extracted width value if found, otherwise "No width found" or the maximum numeric value found on the page.
        """
        text_instances = []

        for block in page.get_text("dict")["blocks"]:
            for line in block.get("lines", []):
                for span in line.get("spans", []):
                    text_instances.append((span["text"], span["bbox"]))
        for text, bbox in text_instances:
            if "Width" in text or "width" in text or "WIDTH" in text:
                words = text.split()
                for i, word in enumerate(words):
                    if word.lower() == "width" and i < len(words) - 1:
                        try:
                            return float(words[i + 1])
                        except ValueError:
                            continue

        numbers = []
        for text, _ in text_instances:
            for word in text.split():
                try:
                    numbers.append(float(word))
                except ValueError:
                    continue
        return max(numbers, default=None) if numbers else "No width found"

    def process_pdf(self):
        """
        Processes the specified page of the PDF, extracting the width value, and saves the result to an Excel file.
        """
        widths = []

        with fitz.open(self.pdf_path) as pdf:
            if self.page_number <= len(pdf):
                page = pdf.load_page(self.page_number - 1)
                width = self.extract_width_with_context(page)
                widths.append({"Page": f"Page {self.page_number}", "Width": width})

        widths_df = pd.DataFrame(widths)
        widths_df.to_excel(self.output_excel, index=False)
        print(f"Extracted widths have been saved to {self.output_excel}")
        files.download(self.output_excel)

uploaded = files.upload()
for file_name in uploaded.keys():
    if file_name.lower().endswith('.pdf'):
        page_number = 2  # Set the specific page number here
        output_excel = "/content/extracted_widths.xlsx"
        pdf_extractor = PDFWidthExtractor(file_name, output_excel, page_number)
        pdf_extractor.process_pdf()

"""# **Extracting Widths from Autodesk Inventor Practice Part Drawings for All Figures in the PDF**"""

!pip install PyMuPDF
import fitz
import pandas as pd
from google.colab import files

class PDFWidthExtractor:
    """
    A class to extract width values from a PDF and save them to an Excel file.

    Attributes:
        pdf_path (str): The path to the PDF file to process.
        output_excel (str): The path to the output Excel file.
    """

    def __init__(self, pdf_path, output_excel):
        """
        Initializes the PDFWidthExtractor with the specified PDF path and output Excel path.

        Args:
            pdf_path (str): Path to the PDF file.
            output_excel (str): Path to the output Excel file.
        """
        self.pdf_path = pdf_path
        self.output_excel = output_excel

    def extract_width_with_context(self, page):
        """
        Extracts width values from a single PDF page by searching for occurrences of the word "width".

        Args:
            page: A page object from the PDF.

        Returns:
            float: The extracted width value if found, otherwise "No width found" or the maximum numeric value found on the page.
        """
        text_instances = []

        for block in page.get_text("dict")["blocks"]:
            for line in block.get("lines", []):
                for span in line.get("spans", []):
                    text_instances.append((span["text"], span["bbox"]))
        for text, bbox in text_instances:
            if "Width" in text or "width" in text or "WIDTH" in text:
                words = text.split()
                for i, word in enumerate(words):
                    if word.lower() == "width" and i < len(words) - 1:
                        try:
                            return float(words[i + 1])
                        except ValueError:
                            continue

        numbers = []
        for text, _ in text_instances:
            for word in text.split():
                try:
                    numbers.append(float(word))
                except ValueError:
                    continue
        return max(numbers, default=None) if numbers else "No width found"

    def process_pdf(self):
        """
        Processes the entire PDF, extracting width values from each page, and saves the results to an Excel file.
        """
        widths = []

        with fitz.open(self.pdf_path) as pdf:
            for i, page in enumerate(pdf, start=1):
                width = self.extract_width_with_context(page)
                widths.append({"Page": f"Page {i}", "Width": width})

        widths_df = pd.DataFrame(widths)
        widths_df.to_excel(self.output_excel, index=False)
        print(f"Extracted widths have been saved to {self.output_excel}")
        files.download(self.output_excel)

uploaded = files.upload()
for file_name in uploaded.keys():
    if file_name.lower().endswith('.pdf'):
        output_excel = "/content/extracted_widths.xlsx"
        pdf_extractor = PDFWidthExtractor(file_name, output_excel)
        pdf_extractor.process_pdf()